#include <iostream>
#include "prime.h"

unsigned int find_divisor_count(unsigned long n);

// The sequence of triangle numbers is generated by adding the natural numbers.
// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first
// ten terms would be:
//
// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
//
// Let us list the factors of the first seven triangle numbers:
//
//  1: 1
//  3: 1,3
//  6: 1,2,3,6
// 10: 1,2,5,10
// 15: 1,3,5,15
// 21: 1,3,7,21
// 28: 1,2,4,7,14,28
//
// We can see that 28 is the first triangle number to have over five divisors.
//
// What is the value of the first triangle number to have over five hundred
// divisors?
//
int main()
{
  // The $n$-th triangular number $T(n)$ has the form:
  //
  // $$ T(n) = \frac{n(n+1)}{2} $$
  //
  // Given the prime factorization of $n$ and $n+1$:
  //
  // $$ n     = p_1^{e_1} + ... + p_s^{e_s} $$
  // $$ n + 1 = q_1^{f_1} + ... + q_t^{f_t} $$
  //
  // and knowing that:
  //
  //     (i) There are no common prime factors shared by $n$ and $n+1$ because
  //         they're consecutive numbers.
  //    (ii) Either $n$ or $n+1$ is even.
  //
  // then, assuming $n$ is even and that $p_1 = 2$ (without loss of generality)
  // then:
  //
  //     (i) $n$ has $D(n) = (e_1 + 1) ... (e_s + 1)$ divisors.
  //    (ii) $n/2$ has $D(n/2) = (e_1) ... (e_s + 1)$ divisors.
  //   (iii) $n+1 has $D(n+1) = (f_1 + 1) ... (f_t + 1)$ divisors.
  //    (iv) $n(n+1)/2$ has $D(n/2) D(n+1)$ divisors.
  //
  // The problem now consists of finding the prime factorization of consecutive
  // integers until $D(n/2) D(n+1) > 500$.

  unsigned long n = 3;
  unsigned int n_div = 0;
  unsigned int np1_div = 0;

  while (n_div * np1_div < 500)
  {
    n += 1;
    n_div = np1_div;
    np1_div = find_divisor_count(n);
  }

  std::cout << (n * (n - 1) / 2) << "\n";
  return 0;
}

unsigned int find_divisor_count(unsigned long n)
{
  auto prime_factors = prime::factorize(n);

  if (prime_factors.empty()) return 1;

  // Adjusting 2's frequency, as explained above
  if (prime_factors[2] > 0) --prime_factors[2];

  unsigned int divisors = 1;
  for (const auto& pf : prime_factors)
  {
    divisors *= (pf.second + 1);
  }

  return divisors;
}