#include <iostream>
#include <set>
#include <array>
#include <numeric>
#include "number.h"

typedef unsigned long poly_num;
typedef std::set<poly_num> poly_set;

void
load_polygonal_numbers(poly_set& triangular_numbers,
                       poly_set& square_numbers,
                       poly_set& pentagonal_numbers,
                       poly_set& hexagonal_numbers,
                       poly_set& heptagonal_numbers,
                       poly_set& octagonal_numbers);

bool
find_chain(std::array<poly_num, 6>& chain,
           const std::vector<const poly_set *const>& polygonal_numbers_set,
           int first_index,
           int last_index);

bool
chain_contains(const std::array<poly_num, 6>& chain, poly_num current);

size_t
length_of_chain(const std::array<poly_num, 6>& chain);

// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
// are all figurate (polygonal) numbers and are generated by the following
// formulae:
//
// Triangle    P_{3,n} = n(n+1)/2   1, 3, 6, 10, 15, ...
// Square      P_{4,n} = n^2        1, 4, 9, 16, 25, ...
// Pentagonal  P_{5,n} = n(3n−1)/2  1, 5, 12, 22, 35, ...
// Hexagonal   P_{6,n} = n(2n−1)    1, 6, 15, 28, 45, ...
// Heptagonal  P_{7,n} = n(5n−3)/2  1, 7, 18, 34, 55, ...
// Octagonal   P_{8,n} = n(3n−2)    1, 8, 21, 40, 65, ...
//
// The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
// interesting properties.
//
//   The set is cyclic, in that the last two digits of each number is the first
//   two digits of the next number (including the last number with the first).
//
//   Each polygonal type: triangle (P_{3,127} = 8128), square (P_{4,91} = 8281),
//   and pentagonal (P_{5,44} = 2882), is represented by a different number in
//   the set.
//
//   This is the only set of 4-digit numbers with this property.
//
// Find the sum of the only ordered set of six cyclic 4-digit numbers for which
// each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
// octagonal, is represented by a different number in the set.
//
int
main(int argc, char *argv[])
{
  poly_num sum;

  poly_set triangular_numbers;
  poly_set square_numbers;
  poly_set pentagonal_numbers;
  poly_set hexagonal_numbers;
  poly_set heptagonal_numbers;
  poly_set octagonal_numbers;

  load_polygonal_numbers(triangular_numbers,
                         square_numbers,
                         pentagonal_numbers,
                         hexagonal_numbers,
                         heptagonal_numbers,
                         octagonal_numbers);

  std::vector<const poly_set *const> polygonal_numbers_set{&triangular_numbers,
                                                           &square_numbers,
                                                           &pentagonal_numbers,
                                                           &hexagonal_numbers,
                                                           &heptagonal_numbers,
                                                           &octagonal_numbers};
  std::array<poly_num, 6> chain{};

  for (const auto& o : octagonal_numbers)
  {
    chain = {};
    chain[5] = o;

    if (find_chain(chain,
                   polygonal_numbers_set,
                   5,
                   5))
      break;
  }

  sum = std::accumulate(chain.begin(), chain.end(), 0ul);

  std::cout << sum << '\n';
  return 0;
}

bool find_chain(std::array<poly_num, 6>& chain,
                const std::vector<const poly_set *const>& polygonal_numbers_set,
                int first_index,
                int last_index)
{
  if (last_index < 0 || last_index >= chain.size())
    throw std::invalid_argument("Last index out of bounds");

  size_t current_length = length_of_chain(chain);
  const poly_num prefix = chain[last_index] % 100;

  for (auto i = 0; i < chain.size(); ++i)
  {
    if (i == last_index) continue;
    if (chain[i] != 0) continue;

    const auto current_set = polygonal_numbers_set[i];

    for (const auto& current_num : *current_set)
    {
      if (chain_contains(chain, current_num)) continue;
      if (prefix != (current_num / 100)) continue;

      chain[i] = current_num;

      if (current_length == (chain.size() - 1))
      {
        if ((current_num % 100) == (chain[first_index] / 100))
          return true;
      }
      else if (find_chain(chain, polygonal_numbers_set, first_index, i))
        return true;
    }

    chain[i] = 0;
  }

  return false;
}

size_t
length_of_chain(const std::array<poly_num, 6>& chain)
{
  size_t length{0};

  for (const auto& c : chain)
    if (c != 0) ++length;

  return length;
}

bool
chain_contains(const std::array<poly_num, 6>& chain, poly_num current)
{
  return std::any_of(
    chain.begin(),
    chain.end(),
    [current](const auto& c)
    {
      return c == current;
    });
}

void
load_polygonal_numbers(poly_set& triangular_numbers,
                       poly_set& square_numbers,
                       poly_set& pentagonal_numbers,
                       poly_set& hexagonal_numbers,
                       poly_set& heptagonal_numbers,
                       poly_set& octagonal_numbers)
{
  for (auto i = 1010; i <= 9999; ++i)
  {
    if (number::is_triangular(i))
      triangular_numbers.insert(i);

    if (number::is_perfect_square(i))
      square_numbers.insert(i);

    if (number::is_pentagonal(i))
      pentagonal_numbers.insert(i);

    if (number::is_hexagonal(i))
      hexagonal_numbers.insert(i);

    if (number::is_heptagonal(i))
      heptagonal_numbers.insert(i);

    if (number::is_octagonal(i))
      octagonal_numbers.insert(i);
  }
}